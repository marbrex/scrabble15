package scrabble.model;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import scrabble.model.GameStatusType;
import scrabble.network.LobbyServer;
import scrabble.network.LobbyServerProtocol;
import scrabble.network.NetworkPlayer;
import scrabble.network.StartGameHandler;

public class GameInformationController {
  /**
   * Class which save and control informations about a network game. Is accessible from multiple
   * server threads.
   * 
   * @author hendiehl
   */
  private LobbyServer mainServer; // server himself
  private ArrayList<NetworkPlayer> players; // List of all players, maximum of 4
  private GameStatusType status; // status => Lobby or Game
  private int gamePort; // port to the GameServer
  private HashMap<NetworkPlayer, Boolean> check; 

  /**
   * constructor which initialize the class
   */
  public GameInformationController(LobbyServer mainServer) {
    this.mainServer = mainServer;
    this.players = new ArrayList<NetworkPlayer>();
    this.status = GameStatusType.LOBBY;
    this.check = new HashMap<NetworkPlayer, Boolean>();
  }

  /**
   * Method which returns the amount of players in a game/lobby. Will be executed by several threads
   * 
   * @return amount of players in game
   */
  public synchronized int getPlayerAmount() {
    return this.players.size();
  }

  /**
   * Method which returns the type of the game status. Will be executed by several threads
   * 
   * @return status of the game
   */
  public synchronized GameStatusType getStatus() {
    return this.status;
  }

  /**
   * Method to add players to a game. Only adds a player if the maximum of 4 players are not
   * reached. Will be executed by several threads
   * 
   * @param player player which want to be added
   * @return information about the success of add procedure
   */
  public synchronized boolean addPlayer(NetworkPlayer player) { // problem of
    if (this.players.size() < 4 && this.status == GameStatusType.LOBBY) {
      this.players.add(player);
      this.check.put(player, false);
      return true; // player added
    } else {
      //this.lobbyFull(); // Perhaps change the call location because of update procedure
      //wrong location do it above
      return false; // player not added because game/lobby is full
    }
  }
  /**
   * Method to check maximum player amount in the lobby and activate the game procedure
   */
  public void checkLobbySize() {
    if(this.players.size() == 4) {
      System.err.println("Maximum Player Amount Joined");
      this.lobbyFull(); //will be called before the last lobby updates  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    }
  }
  /**
   * method to start lobby procedure for full lobby
   */
  public void lobbyFull() { //do it in the StartHandler thread
      this.status = GameStatusType.GAME;
      StartGameHandler starter = new StartGameHandler(this);
      starter.start(); //start the starting procedure.
  }

  /**
   * method to inform the clients that the lobby maximum is reached
   */
  public synchronized void sendFullMessages() {
    for (NetworkPlayer player : this.players) {
      player.sendFullMessage();
    }

  }
  /**
   * Method to inform the lobby that the game will start
   */
  public synchronized void sendStartMessage() {
    for(NetworkPlayer player : this.players) {
      player.sendStartMessage();
    }
  }

  /**
   * Method to set the status of the game/lobby.
   */
  public synchronized void setGameStatusOnGame() {
    this.status = GameStatusType.GAME;
  }

  /**
   * Method to set the port of a specific starting game.
   * 
   * @param port port given and generated by the LobbyServer which are used by the game server
   */
  public synchronized void setGamePort(int port) {
    this.gamePort = port;
  }

  /**
   * method to get the position of an player in reason to show them on the Lobby Screen.
   * 
   * @param player Player which position should be find
   * @return return the index of the player (0-3) or 5 if not in the list
   */
  public synchronized int getPlayerPosition(NetworkPlayer player) {
    if (this.players.contains(player)) {
      return this.players.indexOf(player);
    } else {
      return 5; // later changed with exception
    }
  }

  /**
   * Method to get all Player profiles in the Lobby
   * 
   * @return List of all Player profiles
   */
  private ArrayList<Player> getPlayersInformation() {
    ArrayList<Player> players = new ArrayList<Player>();
    for (NetworkPlayer player : this.players) {
      players.add(player.getPlayer());
    }
    return players;
  }

  /**
   * Method to update the lobby informations of all players.
   */
  public synchronized void updateAllLobbys() {
    ArrayList<Player> playersArrayList = this.getPlayersInformation();
    for (NetworkPlayer player : this.players) {
      System.err.println("Update all ");
      player.updateLobbyinformation(playersArrayList);
    }
    System.err.println("LOBBY UPDATE : " + playersArrayList.size());
  }

  /**
   * Method to delete a player from the game/lobby.
   * 
   * @param player
   */
  public synchronized void deletePlayer(NetworkPlayer player) { //Possibility of a Deadlock, because of the election
    if (this.players.contains(player)) {
      this.players.remove(player);
      this.check.remove(player);
      this.updateAllLobbys();
      this.checkGameStart(); //just in case that a player left the lobby directly after all other players send their sequence
    }
  }

  /**
   * method called by an host to kick a specific player in the lobby
   * 
   * @param i number of the player in the lobby
   */
  public void kickPlayer(int i) {
    if (i < this.players.size()) {
      System.err.println("Kick Player : " + i);
      LobbyServerProtocol player = (LobbyServerProtocol) this.players.get(i); // will be changed in
                                                                              // future first
                                                                              // approach.
      player.sendKickMessage();
      player.deletePlayer();
    }
  }

  /**
   * method to sort the list in a specific sequence
   */
  private void setPlayerSequence() {
    this.players.sort(new Comparator<NetworkPlayer>() {

      @Override
      public int compare(NetworkPlayer arg0, NetworkPlayer arg1) {
        if (arg0.getSequencePos() > arg1.getSequencePos()) {
          return 1;
        } else if (arg0.getSequencePos() < arg1.getSequencePos()) {
          return -1;
        } else {
          if(players.indexOf(arg0) > players.indexOf(arg1)) {
            return 1;
          } else if(players.indexOf(arg0) < players.indexOf(arg1)) {
            return -1;
          }
          return 0;
        }
      }

    });
  }
  /**
   * Method used by Protocols to add the sequence chosen by a member of the Lobby to the protocols
   * @param pos position array of the user election
   */
  public synchronized void addSequence(int[] pos, NetworkPlayer caller) { // need to implement a callback, so the position can be calculated.
    this.check.replace(caller, true);
    for(int i = 0; i < this.players.size(); i++) {
       this.players.get(i).addSequence(pos[i]); //adding a elected position to a protocol 
    }
    this.checkGameStart();
  }
  /**
   * Method to check if all protocols have send the election sequence;
   */
  private void checkGameStart() {
    boolean checker = true;
    for(NetworkPlayer player : this.players) {
      checker &= this.check.get(player);
    }
    if(checker) {
      System.err.println("Game starts from GameInformation controller");
      this.startGame();
    }
  }
  /**
   * Method to start the game itself
   */
  private void startGame() {
    this.setPlayerSequence();
    System.err.println("Game Messages will be sended");
    this.sendGameMessage();
  }
  /**
   * Inform the players that the Game starts
   */
  private void sendGameMessage() {
    for(NetworkPlayer player : this.players) {
      player.sendGameMessage();
    }
  }
}
