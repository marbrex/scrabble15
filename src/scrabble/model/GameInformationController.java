package scrabble.model;

import java.util.ArrayList;
import java.util.Comparator;

import scrabble.model.GameStatusType;
import scrabble.network.LobbyServer;
import scrabble.network.LobbyServerProtocol;
import scrabble.network.NetworkPlayer;

public class GameInformationController {
  /**
   * Class which save and control informations about a network game. Is accessible from multiple
   * server threads.
   * 
   * @author hendiehl
   */
  private LobbyServer mainServer; // server himself
  private ArrayList<NetworkPlayer> players; // List of all players, maximum of 4
  private GameStatusType status; // status => Lobby or Game
  private int gamePort; // port to the GameServer

  /**
   * constructor which initialize the class
   */
  public GameInformationController(LobbyServer mainServer) {
    this.mainServer = mainServer;
    this.players = new ArrayList<NetworkPlayer>();
    this.status = GameStatusType.LOBBY;
  }

  /**
   * Method which returns the amount of players in a game/lobby. Will be executed by several threads
   * 
   * @return amount of players in game
   */
  public synchronized int getPlayerAmount() {
    return this.players.size();
  }

  /**
   * Method which returns the type of the game status. Will be executed by several threads
   * 
   * @return status of the game
   */
  public synchronized GameStatusType getStatus() {
    return this.status;
  }

  /**
   * Method to add players to a game. Only adds a player if the maximum of 4 players are not
   * reached. Will be executed by several threads
   * 
   * @param player player which want to be added
   * @return information about the success of add procedure
   */
  public synchronized boolean addPlayer(NetworkPlayer player) { // problem of
    if (this.players.size() <= 4) {
      this.players.add(player);
      return true; // player added
    } else {
      this.lobbyFull(); // Perhaps change the call location because of update procedure
      return false; // player not added because game/lobby is full
    }
  }

  /**
   * method to start lobby procedure for full lobby
   */
  private void lobbyFull() {
    // TODO Auto-generated method stub
    this.sendFullMessages();
  }

  /**
   * method to inform the clients that the lobby maximum is reached
   */
  private void sendFullMessages() {
    for (NetworkPlayer player : this.players) {
      player.sendFullMessage();
    }

  }

  /**
   * Method to set the status of the game/lobby.
   */
  public synchronized void setGameStatusOnGame() {
    this.status = GameStatusType.GAME;
  }

  /**
   * Method to set the port of a specific starting game.
   * 
   * @param port port given and generated by the LobbyServer which are used by the game server
   */
  public synchronized void setGamePort(int port) {
    this.gamePort = port;
  }

  /**
   * method to get the position of an player in reason to show them on the Lobby Screen.
   * 
   * @param player Player which position should be find
   * @return return the index of the player (0-3) or 5 if not in the list
   */
  public synchronized int getPlayerPosition(NetworkPlayer player) {
    if (this.players.contains(player)) {
      return this.players.indexOf(player);
    } else {
      return 5; // later changed with exception
    }
  }

  /**
   * Method to get all Player profiles in the Lobby
   * 
   * @return List of all Player profiles
   */
  private ArrayList<Player> getPlayersInformation() {
    ArrayList<Player> players = new ArrayList<Player>();
    for (NetworkPlayer player : this.players) {
      players.add(player.getPlayer());
    }
    return players;
  }

  /**
   * Method to update the lobby informations of all players.
   */
  public synchronized void updateAllLobbys() {
    ArrayList<Player> playersArrayList = this.getPlayersInformation();
    for (NetworkPlayer player : this.players) {
      System.err.println("Update all ");
      player.updateLobbyinformation(playersArrayList);
    }
    System.err.println("LOBBY UPDATE : " + playersArrayList.size());
  }

  /**
   * Method to delete a player from the game/lobby.
   * 
   * @param player
   */
  public synchronized void deletePlayer(NetworkPlayer player) {
    if (this.players.contains(player)) {
      this.players.remove(player);
      this.updateAllLobbys();
    }
  }

  /**
   * method called by an host to kick a specific player in the lobby
   * 
   * @param i number of the player in the lobby
   */
  public void kickPlayer(int i) {
    if (i < this.players.size()) {
      System.err.println("Kick Player : " + i);
      LobbyServerProtocol player = (LobbyServerProtocol) this.players.get(i); // will be changed in
                                                                              // future first
                                                                              // approach.
      player.sendKickMessage();
      player.deletePlayer();
    }
  }

  /**
   * method to sort the list in a specific sequence
   */
  public void setPlayerSequence() {
    this.players.sort(new Comparator<NetworkPlayer>() {

      @Override
      public int compare(NetworkPlayer arg0, NetworkPlayer arg1) {
        if (arg0.getSequencePos() > arg1.getSequencePos()) {
          return 1;
        } else if (arg0.getSequencePos() < arg1.getSequencePos()) {
          return -1;
        } else {
          return 0; // case of same amount ?
        }
      }

    });
  }
}
